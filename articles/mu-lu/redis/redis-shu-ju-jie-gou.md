# Redis数据结构

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

## 1. SDS

* 记录了字符串的长度，获取长度时间复杂度为o(1)
* 可以提前知道字符串长度，防止字符串缓冲区溢出
* 通过预留空间，减少修改字符串长度时所需的内存重分配的次数

## 2. 链表

## 3. 字典

* 用链地址法解决哈希冲突
* rehash，新建一个hash表，将原来的hash表元素逐个重新计算hash加到新的hash表，直到元素全部rehash完成，释放原来的hash表，并新建一个空白的hash表用于下一次rehash
*   渐进式rehash

    如果字典数据量很大，一次将所有元素rehash会导致服务器无法正常工作，因此字典的hash过程是渐进式的。rehash开始，字典会维护一个rehashidx变量，初始值为0。每次对ht\[0]进行操作时，除了将元素写一份到ht\[1]，还会将index=rehashidx的元素rehash到ht\[1]，直到所有元素rehash完成，采用分治的思想。

## RDB持久化

* 全量持久化到文件
* SAVE命令阻塞服务器，BGSAVE fork一个子进程来处理持久化
* BGSAVE命令执行期间，SAVE、BGSAVE、BGREWRITEAOF命令都被禁止执行，防止竞争
* 优势
  * 全量快照备份，适合灾难恢复
  * 可以fork子进程的方式，最大化redis的性能
  * 恢复大数据集的速度更快
* 劣势
  * 容易丢数据，还没来得及做快照的数据将会丢掉
  * fork进程会占用cpu

## AOF持久化

AOF分为命令追加、文件写入、文件同步三个步骤

AOF以日志的形式追加到文件中存储，每次服务器恢复时会重放AOF日志用以恢复数据。且redis使用AOF文件重写的机制，将一些无用的命令重写，只记录最后的数据状态。

* 优势
  * 可以定时持久化，即使丢数据也只会丢1s的数据
  * AOF文件重写时会同时向未重写的文件写入，会保证数据的绝对安全
  * AOF文件可以恢复到任意一秒的状态
  * AOF文件更容易看懂

## 哨兵模式

多台redis服务器分为一台主服务器和若干台从服务器，主服务器负责处理读写请求，从服务器负责从主服务器复制数据，哨兵系统会监听主服务器和每台从服务器，如果主服务器无法处理请求，哨兵会从从服务器选出一台服务器作为新的主服务器，当原来的主服务器从新恢复，哨兵会将他加入到从服务器。



