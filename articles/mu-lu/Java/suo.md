# 锁

## 乐观锁和悲观锁

*   乐观锁CAS

    compare and swap\
    读写的内存值V\
    变量操作提交时的值A\
    要写入的新变量值B\
    只有当V==A时，才可以将写入的新值B提交

    * ABA问题:加版本号，JDK提供AtomicStampedReference通过比较变量值的引用和标志来解决
    * 循环时间过长:如果一直失败，循环的开销过大
    * 只能同步一个变量:JDK提供AtomicReference类可以将多个变量放到一个对象中进行CAS
* 悲观锁

## 自旋锁

如果任务的执行时间很短，甚至小于线程上下文切换的时间，可以用自旋锁来实现，自选锁就是修改同步变量失败时，不会进行阻塞状态，而是稍微等一下再次尝试。



## 无锁 偏向锁 轻量级锁 重量级锁

对象头: Mark Word  Klass Point

Monitor

*   无锁:

    多个线程都能修改同一个变量，但是只有一个能提交成功
*   偏向锁

    如果一把锁多次只被一个线程获取，那么这个锁对象的对象头Mark Word就会通过CAS设置这个线程的线程id，下一次线程获取锁时，如果线程id和对象头的线程id一致，就无须通过CAS
*   轻量级锁

    ![](../../.gitbook/assets/image.png)

    当偏向锁被第二个线程访问时，会升级为轻量级锁，jvm会在当前线程的栈桢中创建一个Lock Record，并把锁对象的Mark Word尝试以CAS的形式拷贝到Lock Record，如果更新成功，该线程就会获取这把锁。如果轻量级锁更新失败，虚拟机会检查该锁的对象头是否指向当前线程的栈帧，如果是则代表当前线程已经获取了这把锁，可以直接进入同步代码块执行。否则，若当前只有一个线程等待，该线程会自旋，当自旋到一定次数，或者有第三个线程来获取锁，会升级为重量级锁。
*   重量级锁

    此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

## 公平锁和非公平锁

* 公平锁是获取锁的按照顺序，只有队列第一个线程会获取锁，其他线程全部阻塞，每个尝试获取锁的线程都放到队列的末尾排队，公平锁的优点是等待锁的线程不会被饿死。
* 非公平锁是所有线程都参与锁的竞争，非公平锁的优点时减少很多线程阻塞的cpu开销。

## 可重入锁和非可重入锁

* 可重入锁指一个线程获取到锁以后，这个线程的多个子流程都可以获取锁，其他线程只能等所有子流程执行完毕释放锁后才能获取锁。可重入锁获取锁时，会判断持有锁的线程和当前线程是否为同一个线程，如果是则可以进入同步块执行。



