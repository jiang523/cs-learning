# MVCC

MVCC即多版本并发控制，是mysql用于多个线程读取同一份数据时保证数据一致性的机制。

每个事务开启时mysql都会为该事务分配一个递增的transaction id(下文称tid)，对一份数据做一次修改都会为这份数据建一个版本，并分配一个版本号row\_trx\_id，这个版本号就是修改的事务对应的tid.

<figure><img src="../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

如图，每次数据变更都会记录对应的版本号，多个版本号组成了版本链，可以通过指针找到上一个版本，并通过undolog计算出上个版本的数据值。

在可重复读的隔离级别下，事务开启时，会被分配一个tid，然后mysql会将当前所有活跃的事务(已开启未提交)的tid组成一个tid数组，这个数组里的最小值称为当前事物的低水位，当前事务tid+1称为高水位，高水位+tid数组组成的结构称为一致性视图readview.

对于一致性视图，有以下原则:

1. 低水位以下的数据可以被读到
2. 高水位以上的数据不可被读到
3. tid数组的数据不能被读到

下面用一组例子说明

<figure><img src="../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

假设当前已经只有一个事务，tid=90,事务A=100，事务B=101,事务C=102,k的值为1版本号为80，则这三个事务的读取数据情况是这样的

1. 事务A,B分别开启readview，事务C等执行update操作时开启readview，三个readview的tid数组分别为\[90,100],\[90,100,101],\[90,100,101,102]
2. 事务c更新k的值，则建立了一个「102 -> 2」的版本数据，此时事务B更新k，执行当前读，读到k的值为2，然后事务B更新k，建立一个\[101 -> 3]的版本，此时版本链条为\
   「80 -> 1」=>「102 -> 2」=> \[101 -> 3]
3. 事务B查询k，到版本链上读取，发现最新一条的版本为当前事务版本，所以食物B读到的k值为3
4. 事务A查询k，到版本链上读取，发现最新一条版本为101等于高水位，不可读取，再往上是102，大于高水位也不可读取，再往上读到版本为80，低于低水位，可以读取，因此A读到k的值为1

这里有一个重点，事务中数据的更新都是当前读，而不是快照读，否则会丢失数据。

但是如果下下面这种情况

<figure><img src="../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

事务C'更新k时，没有提交事务，B的更新读到的k应该是多少呢？答案还是3，因为事务C'更新时未提交，也就没有释放k的行锁，此时B的更新操作会被阻塞，直到C'提交事务后才能更新。
