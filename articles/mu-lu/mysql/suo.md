# 锁

和很多数据库、中间件一样，mysql作为一款多用户共享资源的软件，会经常性的出现并发访问的情况，因此mysql需要设计合理的并发控制规则，在保证并发访问时的数据正确性的同时，也要保证系统的可用性和高性能。

锁就是实现这些合理的并发控制规则的一种重要的数据结构。

## 锁的分类

*   读锁(共享锁)

    在多个事务读同一份数据时，会给这份数据加上读锁，多个读操作可以同时进行，互不影响。例如事务T正在读数据A，会给A加上读锁，此时其他事务再来访问数据A时，只能给A加上读锁而不能加上写锁，同时事务T在释放读锁之前，也不能对数据做任何修改操作。

    简单的来说，对数据做读操作时，可以允许任何事务来读，而不允许任何事务来写。
*   写锁(排他锁)

    在对数据做写操作时，会给这份数据加上写锁，被加上写锁的数据，不允许其他事务做读和写操作。例如事务T正在修改数据A，会给A加上写锁，此时只有事务T能对数据A进行读写，而除了T以外的任何事务都无法进行读写。

## 全局锁

全局锁是粒度最大的锁，顾名思义，全局锁是给整个数据库实例加上锁。

MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

实际使用中加上全局锁将导致整个数据库读写不可用，因此全局锁的使用场景很少，一般可以用于数据库备份。



## 表级锁

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

\
首先介绍元数据锁MDL，MDL不需要显式的调用，在访问一张表时会被自动加上。在对一张表做增删改查时，会被加上MDL读锁；在对一张表做表结构修改操作时，会加上MDL写锁。

MDL锁的作用在于，对数据做增删改查时，如果有另外一个线程修改了表结构，那对数据的操作结果肯定是不正确的，因此在对表结构修改时，需要将整张表锁定。

随之而来的就有一个问题，在对表结构做修改期间，将造成该表的读写操作被阻塞，如果这张表有着很高的访问量，将造成一段时间的业务不可用甚至如果客户端有重试机制重启一个session来执行sql的话，可能会把数据库打爆。

因此在给热点表修改表结构时，需要查询innodb\_trx表是否存在该表正在执行中的长事务，因为长事务会长时间占用MDL锁，应该需要在MDL锁被释放后在执行表结构变更。

阿里云mysql数据库的方案也可以参考，在修改表结构时，可以考虑新建一张表结构变更后的新表，将原表的数据清洗一份到新表，最后在某个时间段将新表重命名代替原来的表。这样做的话会更加的平滑。



表锁与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。



## 行锁

### 行锁的概念

行锁是mysql中粒度最小的一种锁，表示只能对当前的行记录加锁。行锁是innodb存储引擎特有的锁，这也是myisam更多的被innodb代替的一个重要原因(另一个是innodb支持事务)。

innoDB存储引擎默认采用行锁，行级锁锁定粒度最小，发生锁冲突的概率最低，并发度也最高。但是行锁开销大，加锁慢，会出现死锁。&#x20;

**InnoDB是基于索引来完成行锁，因此行锁加只能加在索引上。**

这是一个非常值得注意的问题，如果我们在使用索引时索引失效了，那么mysql会进行全表扫描，锁的粒度也将由行锁退化成表锁。

### 两阶段锁

**在innoDB中，行锁是在需要的时候加上的，但是是在事务结束的时候释放的。**

举个简单的例子

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

B事务的操作会出现什么现象？答案是B事务会被阻塞。在A事务开启后，将会持有id=1,2两条记录的写行锁，但是执行完成后写锁并没有释放，而是commit以后才会释放，因此事务B在A事物commit之前对id=1的操作会被阻塞。

**如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。**

### 行锁的分类

在innoDB中，行锁有着三种分类:

* Record Lock : 对命中的索引项加锁。
* Gap Lock: 对索引的间隙范围加锁，并不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。
* Next-Key Lock: 对间隙范围和索引项本身都加锁，可以解决幻读问题。innoDB默认使用Next-Key Lock，Next-Key Lock = Record Lock + Gap Lock

### 分析行锁的竞争情况

通过检查InnoDB\_row\_lock状态变量来分析系统上的行锁的争夺情况，命令如下:

```sql
show status like 'innodb_row_lock%';
```

各个状态量的说明如下：

innodb\_row\_lock\_time:从系统启动到现在锁定总时间长度（等待总时长） innodb\_row\_lock\_time\_avg:每次等待所花平均时间（等待平均时长） innodb\_row\_lock\_time\_max:从系统启动到现在等待最长的一次所花事件 innodb\_row\_lock\_waits：系统启动后到现在总共等待的次数（等待总次数）innodb\_row\_lock\_current\_waits:当前正在等待锁定的数量

## 死锁

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

比如这个例子，A事务一开始给id = 1,2的记录加上了写行锁，B事务给id=3,4的记录加上写行锁。此时A事务要查询id=3的记录，要给id=3的记录加上读行锁，由于id=3的记录已经被B事务加上写锁了，A事务无法执行这条查询语句，进入阻塞状态，等待事物B释放id=3的锁。

而后B事务要为id=1的记录加读锁，相同的情况id=1的记录被事务A加上写锁了，事务B也被阻塞。此时A事务和B事务都在等待彼此释放写锁，进入无限等待的状态，直到事务超时失败。

死锁有两种解决策略:

* 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb\_lock\_wait\_timeout 来设置。
* 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb\_deadlock\_detect 设置为 on，表示开启这个逻辑。

第一种策略让持有锁的事务等待一个长时间(默认50s)后退出，往往是不可接受的，如果设置一个较短的时间又容易对一些本身耗时的事务造成"误伤"，但是如果可以合理的评估一个较短并且业务允许的超时时间，这种策略是可行且成本最低的。

第二种策略被更多的使用，主动的死锁检测能让死锁及时的被发现，但是与此同时，主动的死锁检测也需要额外的开销的。你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。

如果有100个线程同时访问一行记录，那么就需要进行接近100\*100=10000次死锁检测，这需要消耗大量的CPU资源。

因此有时我们会发现一种现象，数据库服务器CPU使用率很高，但是服务TPS却不高。造成这种现象的原因很有可能是因为死锁检测消耗了大部分的CPU资源。

如何解决这种问题呢?

最简单的当然是直接关掉主动死锁检测，但是关掉又无法处理死锁出现的情况了。

另一个思路是控制数据库针对同一行记录的并发度，可以借助mq做排队处理，让同一时刻只有少数线程来修改同一行记录，这样可以降低死锁检测的成本。

此外，针对一些热点行数据，我们可以将记录做一些拆分。例如商品的库存数量，可以将一个商品拆分成几条记录，修改库存的操作就可以分摊到几条行记录上，也可以降低并发竞争。

## 隔离级别和锁的关系

* 在读取未提交Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突
* 在读取已提交Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁。
* 在可重复读Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。
* 可串行化SERIALIZABLE是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成



