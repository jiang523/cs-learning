# 锁

和很多数据库、中间件一样，mysql作为一款多用户共享资源的软件，会经常性的出现并发访问的情况，因此mysql需要设计合理的并发控制规则，在保证并发访问时的数据正确性的同时，也要保证系统的可用性和高性能。

锁就是实现这些合理的并发控制规则的一种重要的数据结构。

## 锁的分类

*   读锁(共享锁)

    在多个事务读同一份数据时，会给这份数据加上读锁，多个读操作可以同时进行，互不影响。例如事务T正在读数据A，会给A加上读锁，此时其他事务再来访问数据A时，只能给A加上读锁而不能加上写锁，同时事务T在释放读锁之前，也不能对数据做任何修改操作。

    简单的来说，对数据做读操作时，可以允许任何事务来读，而不允许任何事务来写。
*   写锁(排他锁)

    在对数据做写操作时，会给这份数据加上写锁，被加上写锁的数据，不允许其他事务做读和写操作。例如事务T正在修改数据A，会给A加上写锁，此时只有事务T能对数据A进行读写，而除了T以外的任何事务都无法进行读写。

## 全局锁

全局锁是粒度最大的锁，顾名思义，全局锁是给整个数据库实例加上锁。

MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

实际使用中加上全局锁将导致整个数据库读写不可用，因此全局锁的使用场景很少，一般可以用于数据库备份。



## 表级锁

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

\
首先介绍元数据锁MDL，MDL不需要显式的调用，在访问一张表时会被自动加上。在对一张表做增删改查时，会被加上MDL读锁；在对一张表做表结构修改操作时，会加上MDL写锁。

MDL锁的作用在于，对数据做增删改查时，如果有另外一个线程修改了表结构，那对数据的操作结果肯定是不正确的，因此在对表结构修改时，需要将整张表锁定。

随之而来的就有一个问题，在对表结构做修改期间，将造成该表的读写操作被阻塞，如果这张表有着很高的访问量，将造成一段时间的业务不可用甚至如果客户端有重试机制重启一个session来执行sql的话，可能会把数据库打爆。

因此在给热点表修改表结构时，需要查询innodb\_trx表是否存在该表正在执行中的长事务，因为长事务会长时间占用MDL锁，应该需要在MDL锁被释放后在执行表结构变更。

阿里云mysql数据库的方案也可以参考，在修改表结构时，可以考虑新建一张表结构变更后的新表，将原表的数据清洗一份到新表，最后在某个时间段将新表重命名代替原来的表。这样做的话会更加的平滑。



表锁与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。



## 行锁

### 行锁的概念

行锁是mysql中粒度最小的一种锁，表示只能对当前的行记录加锁。行锁是innodb存储引擎特有的锁，这也是myisam更多的被innodb代替的一个重要原因(另一个是innodb支持事务)。

innoDB存储引擎默认采用行锁，行级锁锁定粒度最小，发生锁冲突的概率最低，并发度也最高。但是行锁开销大，加锁慢，会出现死锁。&#x20;

**InnoDB是基于索引来完成行锁，因此行锁加只能加在索引上。**

这是一个非常值得注意的问题，如果我们在使用索引时索引失效了，那么mysql会进行全表扫描，锁的粒度也将由行锁退化成表锁。

### 两阶段锁

**在innoDB中，行锁是在需要的时候加上的，但是是在事务结束的时候释放的。**

举个简单的例子

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

B事务的操作会出现什么现象？答案是B事务会被阻塞。在A事务开启后，将会持有id=1,2两条记录的写行锁，但是执行完成后写锁并没有释放，而是commit以后才会释放，因此事务B在A事物commit之前对id=1的操作会被阻塞。

### 行锁的分类

在innoDB中，行锁有着三种分类:

* Record Lock : 对命中的索引项加锁。
* Gap Lock: 对索引的间隙范围加锁，并不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。
* Next-Key Lock: 对间隙范围和索引项本身都加锁，可以解决幻读问题。
