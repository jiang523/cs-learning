# 分布式锁

1. 数据库
2. setNx
   1. 用lua的一条原子命令实现，set key value expire，由于redis是单线程，所有只有一个实例可以执行成功，其中这个value需要是加锁的线程的唯一标识别
   2. 解锁时需要判断解锁的线程是否和value是对应的，只有对应的情况下才能把锁删除，否则会引起锁的误删
   3. 问题
      1. 不可重入
      2. 不可重试
      3. 不可续期
3. zookeeper
   1. zk通过建立临时顺序节点的方式实现分布式锁，多个线程只有一个线程能成功创建/lock/001 节点，创建失败的线程会建立一个/lock/002节点，并且对/lock/001节点做watch，当/lock/001节点被删除，zk通过watch机制通知后面的节点，成功获取锁
4. watch dog机制
   1. redission实现了watch dog机制，如果任务的执行时间超过了分布式锁的过期时间，后台的timer task会使用lua脚本对分布式锁进行续期，默认每10s续期一次，一次续期30s。这个续期不是无脑的，而是要判断分布式锁有没有被删除，如果没有被删除说明任务没有执行结束，才对其进行续期。如果已经被删除了，则不进行续期。
   2. 需要注意的是，如果任务一直没有执行完成，会一直进行续期。如果发生jvm宕机这种情况，则续期的代码就不会继续执行了，避免了死锁的发生。
5. RedLock
   1. redis对多个节点进行加锁，如果全部加锁成功则获取锁，否则获取失败。当redis宕机时，会选举出新的节点作为主节点，此时新的主节点也会有之前设置的锁，线程可以正常解锁，防止死锁
